
---

## Agent 工作流应用 - MVP 开发计划书 (修订版)

### 一、 MVP 核心目标

构建一个功能最小化但流程完整的单机版应用。用户能够：
1.  在前端使用 **Vue Flow** 可视化地创建和编辑工作流。
2.  工作流包含可独立触发的**开始节点**（如：手动输入）。
3.  从指定的**开始节点**触发工作流，将数据发送到后端执行引擎。
4.  后端引擎能从指定的开始节点开始，**按顺序执行**后续节点。
5.  前端能**接收并展示**工作流的最终运行结果。

### 二、 MVP 关键范围界定 (Scope Definition)

*保持不变，聚焦核心*

*   **[排除] 插件系统:** 所有节点均为内置核心节点。
*   **[排除] 子应用生态:** 纯粹的开发工具，不涉及应用封装与分享。
*   **[排除] 子工作流:** 不支持节点嵌套和复用。
*   **[排除] 复杂的逻辑控制节点:** 暂时不实现循环，`条件判断 (If)` 可选。
*   **[排除] 用户账户与持久化存储:** 工作流保存简化为浏览器 `localStorage` 或手动导入/导出。
*   **[排除] 高级安全模型:** 无需临时令牌、复杂 CORS 策略等。
*   **[排除] 并行执行:** 引擎 MVP 只需实现基于 DAG 依赖的串行执行。

### 三、 技术选型

*   **前端:** **Vue 3** + TypeScript
*   **工作流画布库:** **Vue Flow**
*   **UI 组件库:** Element Plus 或 Naive UI
*   **后端:** Node.js + Express.js / Fastify + TypeScript

### 四、 MVP 任务分解 (Task Breakdown)

---

#### **阶段一：后端核心引擎与 API (约 40% 工作量)**

**目标：** 构建一个能接收工作流 JSON 和 *指定的开始节点*，并从该节点开始执行的无头 (headless) 引擎。

1.  **项目初始化与数据结构:**
    *   搭建 Node.js + TypeScript + Express.js 项目。
    *   用 TypeScript 定义工作流、节点、连接线 (`Edge`) 的核心数据结构。

2.  **工作流执行引擎 (Execution Engine):**
    *   **核心逻辑:** 实现一个 `execute` 函数，接收 `(workflow, startNodeId, initialInputs)` 作为参数。
    *   **执行路径规划:** 从 `startNodeId` 开始，进行图的遍历 (如深度优先或广度优先)，确定需要执行的节点及其顺序。这取代了对整个图进行拓扑排序。
    *   **执行上下文:** 创建一个简单的执行上下文对象，用于在节点间传递数据。
    *   **节点调度器:** 依次调用执行路径上各节点的 `run` 函数。

3.  **实现 MVP 核心节点库:**
    *   **`手动输入 (Manual Input)` [起始节点]:**
        *   在 `meta` 中添加一个标志位，如 `isStartNode: true`。
        *   `run` 函数直接返回从 API 请求中接收到的该节点的初始输入数据。
    *   **`模板 (Template)`:** `run` 函数实现简单的 `{{变量}}` 替换。
    *   **`LLM Prompt`:**
        *   实现简化的模型服务层，从环境变量读取 `API_KEY`。
        *   `run` 函数封装对 OpenAI API 的调用。
    *   **`输出 (Output)` [终点节点]:** `run` 函数将输入数据标记为最终输出。
    *   **`代码 (Code)` [可选，推荐]:** 实现一个**不使用沙箱**的 `eval` 或 `new Function` 来执行 JS 代码，作为 MVP 阶段的万能节点。

4.  **API 接口 (关键变更):**
    *   创建 `POST /api/workflow/run` 接口。
    *   接口接收 **`{ workflow: WorkflowJSON, startNodeId: string, inputs: { [nodeId: string]: any } }`** 格式的请求。`startNodeId` 是本次触发的起点，`inputs` 包含该起点所需的数据。
    *   接口调用执行引擎，并同步返回 `{ success: true, results: { [nodeId: string]: any } }` 或错误信息。

---

#### **阶段二：前端可视化编辑器 (基于 Vue Flow) (约 40% 工作量)**

**目标：** 构建一个用户可以拖拽、连接节点，并能从特定节点触发工作流的界面。

1.  **项目初始化:**
    *   搭建 Vue 3 + TypeScript + Vite 项目。
    *   集成 **Vue Flow** 并配置基础样式。

2.  **实现画布核心功能:**
    *   使用 Vue Flow 实现画布的拖拽、缩放、平移。
    *   创建自定义节点 Vue 组件，实现节点的拖拽、连接、删除。
    *   将画布状态 (节点和连接线) 与 Vue 的响应式状态 (如 Pinia或 `ref`) 进行双向同步。

3.  **实现核心 UI 组件 (关键变更):**
    *   **左侧 - 节点库:**
        *   静态列表，展示内置的 MVP 节点。
        *   支持从库中拖拽节点到画布上。
    *   **右侧 - 配置面板:**
        *   根据选中节点的 `meta.params` 定义，动态渲染配置表单。
        *   **对于 `isStartNode: true` 的节点 (如`手动输入`)，在其配置面板中额外渲染一个“运行”按钮。**
        *   移除全局的“运行”按钮。

4.  **实现工作流的本地存取:**
    *   提供 "保存" 按钮，将当前画布状态序列化为 JSON 存入 `localStorage`。
    *   页面加载时，尝试从 `localStorage` 恢复。

---

#### **阶段三：前后端联调与流程闭环 (约 20% 工作量)**

**目标：** 将前后端连接起来，完成从 **节点触发** 到 **结果展示** 的完整用户体验。

1.  **实现节点触发功能 (关键变更):**
    *   为 `手动输入` 节点配置面板中的“运行”按钮绑定事件。
    *   点击按钮时：
        1.  获取当前节点的 `nodeId` 作为 `startNodeId`。
        2.  收集当前节点配置面板表单中的数据，作为 `inputs`。
        3.  获取整个画布的工作流 JSON。
        4.  将这三部分数据 `{ workflow, startNodeId, inputs }` 打包，通过 `axios` 发送到后端的 `POST /api/workflow/run` 接口。

2.  **结果展示与状态更新:**
    *   在发起请求后，可以给画布上的节点增加“运行中”的视觉状态。
    *   当后端返回结果后，遍历返回的 `results` 对象。
    *   将每个节点的输出结果展示在该节点的配置面板或一个独立的“调试”面板中。
    *   更新节点的视觉状态为“成功”或“失败”。

3.  **打包与部署:**
    *   配置 Vite，将前端构建为静态文件。
    *   配置后端 Express 服务，托管前端静态资源，实现单体部署。

---

