

# Agent 工作流应用 - 总体设计文档

## 一、 总体架构 (Overall Architecture)

这是一个社区驱动的、以本地运行为主的 Agent 快速构建与应用平台。其核心目标是让用户通过可视化的工作流编辑器，低代码地构建复杂的 Agent 逻辑，并将其封装为可交互、可分享的前端应用。

**核心组件：**

1.  **前端 (Frontend):** 一个基于现代 Web 技术的单页应用 (SPA)，提供工作流编辑器、应用管理界面，并作为所有子应用的宿主环境。
2.  **后端 (Backend):** 基于 Node.js 开发，负责数据持久化、静态资源服务、API 接口，以及核心的**工作流引擎**的运行。
3.  **SDK (Software Development Kit):** 一套封装好的 JavaScript 库，方便子前端应用与主平台进行安全、便捷的通信，以触发工作流并接收数据。
4.  **CLI (Command-Line Interface):** 一个命令行工具，用于帮助开发者快速创建、打包和验证符合平台标准的应用包和插件包。
5.  **插件系统 (Plugin System):** 一个开放、安全、版本化的扩展机制，允许社区开发者贡献自定义节点和系统级功能，用户可在平台内一键安装和管理。

## 二、 前端架构与子应用生态

前端不仅是开发工具，更是应用的消费和分享中心。

### 2.1 主界面与核心视图

*   **工作区 (Workspace):** 平台的主界面，以卡片形式展示所有已安装的子应用，提供“运行”、“编辑工作流”、“设置”等快捷操作，并支持创建或导入新应用。
*   **工作流编辑器 (Workflow Editor):** 平台的核心功能，采用经典三栏布局：
    *   **左侧 - 节点库:** 按类别展示所有可用节点，支持拖拽至画布。
    *   **中央 - 画布:** 可视化编排工作流，支持节点的拖拽、连接、缩放和平移。
    *   **右侧 - 配置与调试面板:** 动态渲染选中节点的参数表单，并实时显示其运行日志与输出结果。
*   **应用运行界面 (Application Runtime UI):** 子应用的宿主环境，通过 `<iframe>` 沙箱安全地加载和展示子应用的用户交互界面。
*   **设置 (Settings):** 全局配置中心，用于管理模型服务凭证、安装和管理插件、查看持久化数据等。

### 2.2 标准化应用包 (`.zip`)

为了实现应用的便捷分享与分发，所有子应用都遵循统一的打包规范。

*   **包结构:** 一个标准的 `.zip` 文件，内部包含：
    *   `index.html`: 应用的入口文件。
    *   `manifest.json`: 应用的清单文件，核心元数据。
    *   `workflow.json`: 绑定的默认工作流定义，包含其依赖的插件列表。
    *   `icon.svg`: 应用图标。
    *   静态资源目录 (如 `js/`, `css/`, `assets/`)。
*   **`manifest.json` 清单:** 定义了应用的唯一标识、名称、描述、版本以及入口文件路径。
*   **`workflow.json` 依赖:** 包含一个 `dependencies` 字段，精确记录该工作流运行所需的所有插件及其版本号，确保可移植性和可复现性。

## 三、 通信与安全模型

我们采用一种将部分安全责任交由用户判断的开放模型，以最大化平台的灵活性和社区驱动力。

*   **`<iframe>` 沙箱:** 子应用被严格限制在 `<iframe>` 内运行，利用浏览器原生的安全机制隔离其对主应用 DOM 和全局变量的访问。
*   **选择性 CORS 策略:** 后端 API 默认采用严格的同源策略，仅对执行工作流的端点（如 `POST /api/workflows/{workflowId}/run`）启用 CORS，允许子应用通过 SDK 调用。
*   **风险对冲机制:**
    *   **临时运行令牌 (Ephemeral Run Tokens):** 主应用在加载子应用时，为其会话请求一个与用户绑定的短时效令牌。子应用在调用 API 时必须携带此令牌进行身份验证和权限校验。
    *   **速率限制与监控:** 对开放的 API 端点实施基于用户或令牌的精细化速率限制，防止恶意或有缺陷的应用滥用资源。
    *   **社区监督与信誉体系:** 建立包含评分、评论和举报功能的应用/插件市场，帮助用户在安装前评估其安全性。

## 四、 工作流引擎与节点核心

### 4.1 执行引擎 (Execution Engine)

*   **执行模型:** 基于有向无环图 (DAG) 的依赖关系进行混合执行。有直接数据依赖的节点串行执行，无依赖的并行分支可并发执行。
*   **执行上下文 (Execution Context):** 每次运行都会创建一个完全隔离的执行上下文，包含唯一的 `runId`、**依赖解析映射**等，用于追踪该次运行中所有节点的状态、数据和插件版本，确保并发和嵌套运行时互不干扰。
*   **循环控制:** 通过专用的 `For Each` (迭代数组) 和 `Conditional Loop` (条件循环) 节点实现。后者必须强制设置最大迭代次数，以防止死循环。

### 4.2 模型服务层 (Model Service Layer)

一个解耦的中间层，用于统一管理所有外部模型服务（如 LLM、Embedding 模型）。用户在此处集中配置 API 密钥和模型地址。节点只需选择一个已配置好的模型，无需关心具体的认证细节，增强了安全性和可维护性。

### 4.3 节点设计原则

每个节点都由两部分构成，实现了逻辑与 UI 的分离。
*   **`meta` (元数据):** 一个 JSON 对象，描述节点的类型、标签、输入/输出端口，以及一个用于动态生成配置面板 UI 的 `params` 结构。
*   **`run` (执行函数):** 一个异步函数，接收 `{ input, params, logger }` 作为参数，在受限的沙箱环境中执行节点的核心逻辑。

## 五、 节点组合与嵌套

### 5.1 节点分组 (Grouping) - 视觉层

纯粹的视觉组织工具，用于整理画布，对工作流的执行逻辑**无任何影响**。

### 5.2 子工作流 (Sub-Workflow) - 逻辑层

实现功能封装、逻辑抽象和跨工作流复用的核心机制。
*   **实现:** 通过一个特殊的 `SubWorkflow` 节点引用另一个工作流。被引用的子工作流使用 `SubWorkflowInput` 和 `SubWorkflowOutput` 节点来定义其接口。
*   **执行逻辑:** 引擎通过**执行上下文栈 (Execution Context Stack)** 来处理嵌套。当遇到 `SubWorkflow` 节点时，暂停父流程，为其创建一个**新的、独立的执行上下文**来运行子流程。此模型天然支持无限层级的嵌套和独立的插件版本依赖。

## 六、 核心节点库 (Core Node Library)

平台内置一套基础而强大的核心节点，作为构建 Agent 的基石。

| 分类 | 节点名称 | 功能描述 |
| :--- | :--- | :--- |
| **核心** | **HTTP Webhook** | **[起始]** 生成 URL 接收 HTTP 请求来触发工作流。 |
| | **手动输入** | **[起始]** 提供表单让用户在运行时手动输入数据。 |
| | **HTTP 响应** | **[终点]** 向触发 Webhook 的请求方返回同步响应。 |
| | **输出** | **[终点]** 在应用界面上展示最终结果。 |
| | **代码** | 执行任意 Node.js 代码，提供最大灵活性。 |
| **逻辑控制** | **条件判断 (If)** | 根据条件将数据从 `true` 或 `false` 端口送出。 |
| | **For Each** | 对数组中的每个元素执行一次循环体子流程。 |
| | **Conditional Loop** | 满足条件前重复执行子流程，有最大次数限制。 |
| **数据处理** | **模板 (Template)** | 使用 `{{变量}}` 语法将数据填充到文本模板中。 |
| **数据持久化** | **保存/读取数据** | 以键值对形式持久化存储，实现跨运行记忆。 |
| **大语言模型** | **LLM Prompt** | 调用在“模型服务层”配置好的大语言模型。 |
| **外部集成** | **HTTP 请求** | 以客户端身份调用任何外部 API。 |

## 七、 插件系统 (Plugin System)

插件系统是平台开放性和生态建设的基石。它采用“双轨制安全模型”，清晰地划分了**节点 (Nodes)** 和**钩子 (Hooks)** 两种能力，为不同的扩展需求提供了兼顾安全与灵活性的解决方案。

### 7.1 插件包结构 (Unified Package Format)

所有插件都遵循标准的 npm 包格式，并通过 `package.json` 中的 `amisAgent` 字段来声明其能力和所需权限。

```
my-plugin/
├── package.json         # 插件的核心清单文件
├── nodes/               # 存放所有节点逻辑
│   └── my-node/
│       ├── index.js     # 导出 { meta, run }
│       └── logo.svg
└── hooks/               # 存放所有钩子逻辑
    ├── backend/
    │   └── on-workflow-start.js
    └── frontend/
        └── custom-panel.vue
```

**`package.json` 清单示例:**

```json
{
  "name": "amis-agent-plugin-example",
  "version": "1.0.0",
  "amisAgent": {
    "nodes": {
      "permissions": {
        "network.access": "需要访问外部API获取数据",
        "fs.read": ["/tmp/plugin_data/"]
      }
    },
    "hooks": {
      "backend:workflow:beforeRun": "用于在工作流开始前注入全局变量。",
      "frontend:customEditorPanel": "提供一个数据可视化面板。"
    }
  }
}
```

### 7.2 插件生命周期与安全模型

插件的安全性贯穿其整个生命周期，通过一个四层纵深防御体系来保障。

1.  **第一层：开发者声明 (Developer Declaration)**
    *   **机制:** 开发者在 `package.json` 的 `amisAgent` 字段中，明确声明其节点所需的**沙箱权限** (`nodes.permissions`) 和希望集成的**系统钩子** (`hooks`)。
    *   **目的:** 提高透明度，作为平台分析和用户授权的依据。

2.  **第二层：平台静态分析 (Platform Static Analysis)**
    *   **时机:** 用户点击安装后，在任何代码被执行**之前**。
    *   **机制:** 平台通过 AST 解析等技术，深度扫描插件代码，自动检测敏感 API 调用、混淆代码等风险，并与开发者的声明进行交叉验证。
    *   **目的:** 自动化风险预警，识别出“未声明的权限”或恶意行为。

3.  **第三层：用户授权 (User Authorization)**
    *   **机制:** 在安装前，平台向用户展示一个综合性的安全审查界面，清晰列出开发者声明、平台分析报告，并要求用户对**节点沙箱权限**和**系统钩子权限**进行**细粒度、手动授权**。所有权限默认关闭。
    *   **目的:** 将最终控制权交予用户，确保所有高风险操作都基于用户的知情同意。

4.  **第四层：运行时强制执行 (Runtime Enforcement)**
    *   **节点 (Nodes):** 节点的 `run()` 函数在独立的 **`worker_threads` 沙箱**中执行。平台利用 Node.js 的 **Permission Model** (`--experimental-permission`)，根据用户授权的权限动态创建受限的 Worker。任何越权行为（如访问未授权的网络或文件）都会被运行时立即阻止。
    *   **钩子 (Hooks):** 钩子监听器在**主进程**中执行以获得必要的能力。但其代码只有在**用户已明确授权该钩子**的情况下才会被加载和执行。这是一种基于“事前许可”的门控机制。

### 7.3 版本化与依赖管理

为了确保工作流的可移植性和稳定性，插件系统实现了完善的版本控制。

*   **版本化安装:** 插件按 `包名/版本号` 的结构隔离安装在 `platform-data/plugins/` 目录下，每个版本及其依赖（`node_modules`）都完全独立，杜绝版本冲突。
*   **依赖清单:** 每个 `workflow.json` 都包含一个 `dependencies` 字段，精确记录其依赖的插件包名和版本号（如 `"amis-agent-plugin-wechat": "1.2.1"`）。
*   **依赖检查与同步:** 当用户导入或打开一个工作流时，平台会自动比对工作流的依赖清单与本地已安装的插件。对于缺失或版本不匹配的依赖，会引导用户一键安装所需版本。
*   **上下文感知加载:** 工作流引擎的**执行上下文 (Execution Context)** 会包含当前工作流（或子工作流）的依赖映射。当执行节点时，引擎会根据当前上下文的映射，动态地从正确的版本化目录中加载并执行节点代码，完美解决了父子工作流依赖不同版本插件的冲突问题。

### 7.4 钩子系统：深度集成能力

钩子是平台暴露的系统级事件切入点，允许插件对平台的核心行为和UI进行深度定制。

**后端钩子 (Backend Hooks)**

*   **机制:** 基于 Node.js 的 `EventEmitter` 实现的中央事件总线。插件通过 `hooks/backend/` 下的文件监听并响应事件。
*   **核心钩子列表:**
    *   `platform:afterStartup`: 平台启动后。
    *   `workflow:beforeRun` / `workflow:afterRun`: 工作流执行前后。
    *   `node:beforeExecute` / `node:afterExecute`: 节点执行前后。

**前端钩子 (Frontend Hooks - 注入点)**

*   **机制:** 基于一个全局的、响应式的 Vue 组件注册表。插件通过 SDK 的前端 API 注册自定义 Vue 组件，主应用在预设的注入点动态渲染它们。
*   **核心注入点列表:**
    *   **自定义编辑器面板:** 在编辑器侧边栏添加全新功能面板。
    *   **自定义节点配置UI:** 用自定义 Vue 组件替代默认的参数表单。
    *   **自定义数据渲染器:** 在调试面板中可视化特定格式的数据。
    *   **主工具栏/菜单项:** 添加全局操作按钮。

### 7.5 双轨制安全模型总结

| 特性              | **节点 (Nodes)**                       | **钩子 (Hooks)**                        |
| :--------------- | :------------------------------------- | :-------------------------------------- |
| **目的**         | 构建工作流的具体功能单元                | 对平台行为和UI进行深度定制                |
| **运行环境**     | **`worker_threads` 沙箱** (隔离、受限) | **主进程** (高权限)                      |
| **核心安全机制** | **运行时权限限制** (Permission Model) | **用户事前授权** (Consent-Based Gating) |
| **设计哲学**     | **最小权限原则**：默认无权，按需申请。  | **明确授权原则**：默认禁用，用户激活。    |


好的，您提出的“开发者很懒”和“社区补丁”是非常深刻且实际的洞察。直接要求所有插件开发者都遵循严格的 i18n 规范可能会阻碍生态的早期发展。

ComfyUI 的 i18n 方案正是这种“社区驱动”理念的绝佳实践。我们可以借鉴其核心思想，并结合我们已有的设计，创造一个更加强大和灵活的混合模式。

下面，我将首先分析 ComfyUI 的实现方式，然后为您的设计文档补充一个全新的章节，提出一个兼容两种模式的、更优的国际化方案。

---

### ComfyUI 的国际化 (i18n) 模式分析

ComfyUI 的 i18n 方案非常巧妙，其核心特点是**对节点开发者完全无感知**。

1.  **工作原理:**
    *   **字符串提取:** ComfyUI 的前端在加载时，会扫描所有已加载的 Python 节点代码。它通过**正则表达式**或简单的解析，直接从节点的 `DISPLAY_NAME`、`CATEGORY`、输入参数名等字段中提取出原始的英文字符串。
    *   **动态翻译:** 用户在前端切换语言（例如，切换到中文）后，前端会加载一个对应的语言文件（如 `zh-CN.json`）。这个 JSON 文件是一个巨大的键值对字典，其中 **key 是原始的英文字符串**，**value 是翻译后的字符串**。
    *   **渲染时替换:** 当 UI 需要渲染一个节点名时，它会拿着从代码中提取的原始英文名（如 "Load Image"）去查询已加载的 `zh-CN.json`。如果找到了对应的 key，就显示其 value（"加载图像"）；如果没找到，就直接显示原始的英文名。

2.  **优点:**
    *   **对开发者零负担:** 插件开发者只需用英文编写他们的节点，完全不需要考虑 i18n、创建 `locales` 目录或管理翻译键。这极大地降低了贡献门槛。
    *   **完全社区驱动:** 翻译工作与插件开发完全解耦。任何热心用户都可以为整个 ComfyUI 生态（包括所有第三方插件）贡献翻译。他们只需要维护那个巨大的 JSON 文件即可。
    *   **易于分发:** 翻译文件可以作为独立的“语言包”进行分享和安装。

3.  **缺点:**
    *   **脆弱性:** 翻译基于**字符串精确匹配**。如果原作者修复了一个拼写错误（例如，从 "Loda Image" 改为 "Load Image"），所有语言中基于 "Loda Image" 的翻译都会失效。
    *   **上下文歧义:** 同一个英文单词在不同上下文中可能有不同含义（例如 "Scale" 可以是“缩放”或“规模”）。基于字符串匹配的模式无法区分，会导致翻译不准确。
    *   **不适用于复杂文本:** 对于日志、错误信息或包含变量的长段落，这种简单的键值替换模式难以胜任。

---

## 第八章：社区驱动的国际化 (i18n) 补丁系统

结合 ComfyUI 的成功经验和我们对健壮性的追求，我们设计一套**双轨制、以社区补丁为核心**的国际化系统。它既能服务于“懒”开发者，也为追求完美的开发者提供了高级路径。

### 8.1 核心理念：翻译覆盖层 (Translation Overlays)

我们引入“覆盖层”或“补丁”的概念。任何翻译，无论是社区贡献的还是开发者自己提供的，都被视为对插件原始文本的一个覆盖层。系统会根据优先级智能地应用这些覆盖层。

### 8.2 “懒”开发者路径：零配置的社区翻译

这是为绝大多数开发者设计的默认路径。

1.  **开发体验:**
    *   开发者**无需**创建 `locales` 目录或 `i18n` 配置。
    *   在节点的 `meta` 定义中，直接使用他们的母语（通常是英语）编写所有面向用户的文本。

    ```javascript
    // my-node/index.js - "懒"开发者的写法
    const meta = {
      label: 'My Custom Node',
      description: 'This node performs a special task.',
      params: [
        { name: 'apiKey', label: 'API Key' }
      ]
    };
    ```

2.  **平台侧机制:**
    *   **字符串提取器:** 平台内置一个工具，可以扫描所有已安装插件的 `meta` 定义，自动提取出所有可翻译的字符串（如 `label`, `description` 等）。
    *   **在平台内翻译:** 平台提供一个“**翻译中心**”界面。社区贡献者可以在这里看到所有插件中尚未翻译的文本列表，并为当前语言（如 `zh-CN`）提交翻译。
    *   **生成补丁文件:** 当用户提交翻译后，系统**不会修改插件本身**。而是将翻译结果保存为一个独立的**补丁文件**，存储在平台的用户数据目录中。

    ```
    platform-data/
    └── translations/
        └── zh-CN/
            ├── amis-agent-plugin-example.json  // 对应插件的翻译补丁
            └── another-plugin.json
    ```

    **`amis-agent-plugin-example.json` 文件内容示例:**

    ```json
    {
      "My Custom Node": "我的自定义节点",
      "This node performs a special task.": "该节点用于执行一个特殊任务。",
      "API Key": "API 密钥"
    }
    ```

### 8.3 “专业”开发者路径：官方内置翻译

这是我们之前设计的标准路径，现在作为一种可选的、更高质量的方案。

*   开发者可以在插件包内提供 `locales` 文件夹和 `i18n` 配置。
*   在 `meta` 中使用翻译键（如 `t:myNode.label`）。

### 8.4 统一的翻译解析逻辑 (Unified Resolution Logic)

这套逻辑是整个系统的核心，它决定了最终显示哪个文本。当平台需要渲染一个节点的 `label` 时，会按以下**优先级**进行查找：

1.  **社区补丁 (最高优先级):**
    *   获取 `meta.label` 的原始值（例如 "My Custom Node"）。
    *   在当前语言的社区补丁文件（`translations/zh-CN/plugin-name.json`）中，查找是否存在以该原始值为 key 的条目。
    *   如果找到，则使用补丁中的翻译。**这允许社区覆盖或修正插件自带的翻译。**

2.  **官方内置翻译 (基于键):**
    *   检查 `meta.label` 的值是否以 `t:` 开头（例如 `t:myNode.label`）。
    *   如果是，则按照第八章的逻辑，在插件的 `locales` 文件夹中查找当前语言的翻译。

3.  **官方内置翻译 (基于值 - 降级):**
    *   **这一步是新增的。** 如果 `meta.label` 的值不是以 `t:` 开头（如 "My Custom Node"），系统也会去插件的 `locales` 文件夹中，查找是否有以 "My Custom Node" 为 key 的翻译。这为从“懒”模式过渡到“专业”模式提供了可能。

4.  **原始文本 (最低优先级):**
    *   如果以上步骤均未找到翻译，则直接显示 `meta.label` 的原始值。

### 8.5 总结与优势

| 特性 | **官方 i18n (专业路径)** | **社区补丁 (懒人路径)** |
| :--- | :--- | :--- |
| **开发者工作量** | 需要创建 `locales` 文件和翻译键 | **零工作量** |
| **翻译机制** | 基于唯一的翻译键 (`t:key`) | 基于原始英文字符串匹配 |
| **健壮性** | **高** (不受原文修改影响) | **中** (原文修改后翻译失效) |
| **上下文处理** | **精确** (不同上下文可用不同键) | **模糊** (同一单词只有一个翻译) |
| **社区参与** | 需向开发者提交PR | **在平台内直接贡献，无需接触代码** |
| **最终用户控制** | 无法修改 | **可以自行修改或覆盖不满意的翻译** |

**这种混合模型的巨大优势在于：**

*   **极低的生态门槛:** 鼓励大量开发者快速贡献功能，无需为 i18n 分心。
*   **赋能社区:** 将翻译的主动权交给庞大的用户社区，翻译的覆盖面和速度会远超开发者自己维护。
*   **提供了成长路径:** 当一个插件变得流行和复杂时，其开发者可以随时切换到更健壮的“官方 i18n”模式，而不会破坏已有的社区翻译（因为社区补丁优先级更高）。
*   **最终用户至上:** 用户不仅能享受到社区的翻译成果，甚至可以根据自己的偏好在本地覆盖任何翻译，实现了极致的个性化。 